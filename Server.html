<html>

<head>
  <title>Python Whisper Server</title>
  <script src="/recorder.js"></script>
</head>

<body>
  <div style="display: flex; flex-direction: column;">
    <div style="border: 1px solid black; background: #dddddd">
      <div id="NumberOfMicrophones"></div>
      <div id="Microphones"></div>
    </div>
    <div style="border: 1px solid black; background: #dddddd; display: flex; flex-direction: column;">
      <div>Volume: <label id="lblVolume"></label></div>
      <div>Translations:</div>
      <textarea id="txtResult" cols="80" rows="20"></textarea>
    </div>
  </div>
</body>

<script>

  function translate(data, callback) {
    const req = new XMLHttpRequest();
    req.addEventListener("load", function () {
      //console.log("response:", this.responseText);
      callback(this.responseText);
    });
    req.open("POST", window.location.href + "translate");
    req.timeout = 3000;
    req.setRequestHeader("Content-Type", "application/json");
    req.send(JSON.stringify(data));
  }

  var MicrophonePlugin = {

    mMicrophones: [],

    Init: function () {

      //console.log("Init:");

      const SAMPLE_RATE = 16000;

      var constraints = {
        audio: true
      };

      navigator.getUserMedia = navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia;

      if (navigator.getUserMedia) {

        navigator.getUserMedia(constraints, function (stream) {
          //console.log('navigator.getUserMedia successCallback: ', 'constraints', constraints, 'stream', stream);

          document.position = 0;

          document.audioContext = new AudioContext({ sampleRate: SAMPLE_RATE });
          console.log('sampleRate', document.audioContext.sampleRate);

          document.source = document.audioContext.createMediaStreamSource(stream);

          setInterval(function () {

            if (!document.recorder) {
              document.recorder = new Recorder(document.source, { numChannels: 1 });
              //console.log(new Date(), 'Recorder initialised.');
            } else {
              document.recorder.stop();

              document.recorder.getBuffer(async function (channels) {
                //console.log(new Date(), 'channels', channels);
                let channel = channels[0];
                //console.log(new Date(), channel);
                //console.log(new Date(), 'exported WAV', channel.length, channel);

                let rawWave = [];
                let volume;
                for (let i = 0; i < channel.length; ++i) {
                  let data = channel[i];
                  if (i == 0) {
                    volume = data;
                  } else {
                    volume = Math.max(volume, Math.abs(data));
                  }
                  rawWave.push(data);
                }

                //console.log(new Date(), 'volume', volume);
                if (!Number.isNaN(Number(volume))) {
                  lblVolume.innerText = (Number(volume) * 100).toFixed(1) + "%";
                }
                if (volume > 0.1) {
                  translate({
                    data: rawWave,
                    sampleRate: document.audioContext.sampleRate
                  }, function (text) {
                    if (text.startsWith('{')) {
                      let json = JSON.parse(text);
                      //console.log('translate result:', json.text);
                      if (json.text) {
                        txtResult.value += " " + json.text;
                        //console.log(new Date(), 'length', txtResult.value.length);
                        /*
                        if (txtResult.value.length > 2000) {
                          txtResult.value = txtResult.value.substring(2000);
                        }
                        */
                      }
                    }
                  });
                }
              });
            }

            //console.log(new Date(), 'Recorder recording.');
            document.recorder.clear();
            document.recorder.record();

          }, 1000);

        }, function (error) {
          console.error('navigator.getUserMedia errorCallback: ', error);
        });
      }
    },

    hasGetUserMedia: function () {
      return !!(navigator.getUserMedia || navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia || navigator.msGetUserMedia);
    },

    AddMicrophone: function (device) {
      this.mMicrophones.push(device);
    },

    QueryAudioInput: function (callback) {

      var refThis = this;

      // clear
      this.mMicrophones = [];

      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        console.log("enumerateDevices() not supported.");
      } else {
        // List microphones - async
        navigator.mediaDevices.enumerateDevices()
          .then(function (devices) {
            devices.forEach(function (device) {
              //console.log("QueryAudioInput: kind="+device.kind + " device=", device, " id=" + device.deviceId);
              if (device.kind === 'audioinput') {
                //console.log("QueryAudioInput: kind=audioinput device=", device, " id=" + device.deviceId);
                refThis.AddMicrophone(device);
              }
            });
            callback();
          })
          .catch(function (err) {
            console.error('Error', err.name + ": " + err.message);
          });
      }
    },

    GetNumberOfMicrophones: function () {
      //console.log("GetNumberOfMicrophones length", this.mMicrophones.length);
      return this.mMicrophones.length;
    },

    GetMicrophoneDeviceName: function (index) {
      return this.mMicrophones[index].label;
    }
  };

  MicrophonePlugin.Init();

  setInterval(function () {

    MicrophonePlugin.QueryAudioInput(function () {
      //console.log('Getting number of mics...');
      let numberOfMicrophones = MicrophonePlugin.GetNumberOfMicrophones();
      //console.log('Number of Microphones...', numberOfMicrophones);
      let divNumberOfMicrophones = document.getElementById('NumberOfMicrophones');
      if (divNumberOfMicrophones != undefined) {
        divNumberOfMicrophones.innerText = "Number of Microphones: " + numberOfMicrophones;
      }

      let divMicrophones = document.getElementById('Microphones');
      if (divMicrophones != undefined) {
        let text = '';
        for (let i = 0; i < numberOfMicrophones; ++i) {
          let name = MicrophonePlugin.GetMicrophoneDeviceName(i);
          text += '* ' + name + "\r\n";
        }
        divMicrophones.innerText = text;
      }
    });

  }, 1000);

</script>

</html>